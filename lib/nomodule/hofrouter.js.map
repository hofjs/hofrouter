{
  "version": 3,
  "sources": ["../../node_modules/@hofjs/hofjs/lib/esm/hof.js", "../../src/hofrouter.ts", "../../src/esbuild-wrapper/hofrouter.esbuild.ts"],
  "sourcesContent": ["// https://github.com/prateek3255/typescript-react-demo-library\r\nclass AttributeExpression {\r\n    constructor(execute, bindVariableNames, template) {\r\n        this.execute = execute;\r\n        this.bindVariableNames = bindVariableNames;\r\n        this.template = template;\r\n    }\r\n}\r\n// Base class for all Web components created by this framework\r\nexport class HofHtmlElement extends HTMLElement {\r\n    constructor(tagName = 'div') {\r\n        super();\r\n        this._observersForBindVariable = new Map(); // Map<BindVariableName, Map<DOMElement, AttributeName[]>>\r\n        this._observerExpressions = new Map(); // Map<DOMElement, Map<AttributeName, AttributeExpression>>\r\n        this._properties = {}; // Global properties (of component)\r\n        this._locals = {}; // Local variables (of render function), including list iteration variables such as person0, person1, ...\r\n        this._allBindVariables = null;\r\n        this._allBindExpressions = {};\r\n        this._renderIteration = -1;\r\n        this._listTemplate = null;\r\n        this._listData = [];\r\n        this._listIt = \"\";\r\n        this._listStart = 0;\r\n        this.PROPS_FILTER = (p) => p.charAt(0) != '_' && p != p.toUpperCase() && p != 'constructor' && p != 'render';\r\n        this.REFERENCED_BIND_VARIABLE_NAMES_REGEX = new RegExp('([a-zA-Z_$][\\\\w]+\\\\.[\\\\w\\\\.]+)', 'g');\r\n        this.DERIVED_PROPERTY_SIGNATURE_REGEX = new RegExp(\"^function *\\\\(\\\\)\");\r\n        this._tagName = tagName;\r\n        this._shadow = this.attachShadow({ mode: \"open\" });\r\n    }\r\n    connectedCallback() {\r\n        this._root = document.createElement(this._tagName);\r\n        this._shadow.appendChild(this._root);\r\n        this.render();\r\n    }\r\n    useAutoProps() {\r\n        // Replace all public simple properties with getters and setters,\r\n        // so that access can be intercepted and observability can be realized\r\n        this._forEachPropertyOfObjectAndPrototype((prop, obj) => {\r\n            const initialValue = obj[prop];\r\n            // Fix for event handlers because they cannot be added with defineProperty\r\n            // from component() as long as a web component is not part of the DOM\r\n            if (prop.startsWith(\"event-\")) {\r\n                prop = prop.substring(6);\r\n                delete obj[prop];\r\n            }\r\n            if (prop == \"construct\" && typeof (initialValue) == \"function\") {\r\n                initialValue.call(this);\r\n            }\r\n            else // Default Property handling\r\n                Object.defineProperty(this, prop, {\r\n                    get: function () { return this.getProperty(prop, initialValue); },\r\n                    set: function (v) {\r\n                        const oldValue = this.getProperty(prop, initialValue);\r\n                        if (this._callBindVariableBeforeChangedHook(this, prop, v, oldValue)) {\r\n                            this.setProperty(prop, v);\r\n                            this._callBindVariableAfterChangedHook(this, prop, v, oldValue);\r\n                        }\r\n                    },\r\n                    enumerable: true,\r\n                    configurable: true\r\n                });\r\n        });\r\n    }\r\n    setProperty(name, value) {\r\n        const oldValue = this._properties[name];\r\n        // Render again in case of complex object or on value change of simple property or on collection action\r\n        if (typeof (oldValue) == \"object\" || typeof (value) == \"object\" || oldValue != value || value[\"lastActionMethod\"]) {\r\n            // Process initial element-property setter calls (cache for time after template\r\n            // has been constructed and further binding variables are available)\r\n            this._properties[name] = value;\r\n            // Update properties including local binding variables\r\n            if (this._allBindVariables)\r\n                this._allBindVariables[name] = value;\r\n            this._updatePropertyObservers([name, value]);\r\n        }\r\n        // Make new objects observable\r\n        if (this._allBindVariables)\r\n            this._makeBindVariableObservable(name);\r\n    }\r\n    getProperty(name, initialValue) {\r\n        var _a, _b;\r\n        if (this._allBindVariables)\r\n            return this._allBindVariables[name];\r\n        return (_b = (_a = this._properties[name]) !== null && _a !== void 0 ? _a : this.getAttribute(name)) !== null && _b !== void 0 ? _b : initialValue;\r\n    }\r\n    _hasAlreadyRendered() {\r\n        return this._root.textContent != \"\";\r\n    }\r\n    renderContent(html, locals = undefined) {\r\n        this._renderFull(html, locals);\r\n    }\r\n    renderList(data, html, locals = undefined) {\r\n        const expression = html.toString();\r\n        const listIt = expression.substring(expression.indexOf('(') + 1, expression.indexOf(')'));\r\n        // Liste zum Zeitpunkt des Aufrufs noch nicht aufgel\u00F6st (first rendering), d.h. noch Wert wie ${data}\r\n        if (typeof data == \"string\")\r\n            return;\r\n        this._listData = data;\r\n        this._listIt = listIt;\r\n        this._listTemplate = html;\r\n        this._listStart = this._root.childNodes.length;\r\n        if (typeof (locals) == \"undefined\" || locals == null)\r\n            locals = {};\r\n        for (const listItem of this._listData) {\r\n            locals[this._listIt] = listItem;\r\n            this._renderFull(html, locals);\r\n        }\r\n    }\r\n    _calculateProperties() {\r\n        let result = {};\r\n        this._forEachPropertyOfObjectAndPrototype((prop, obj) => result[prop] = obj[prop]);\r\n        this._allBindVariables = result;\r\n    }\r\n    _forEachPropertyOfObjectAndPrototype(func) {\r\n        for (const name of Object.getOwnPropertyNames(this).filter(this.PROPS_FILTER))\r\n            func(name, this);\r\n        const prototype = Object.getPrototypeOf(this);\r\n        for (const name of Object.getOwnPropertyNames(prototype).filter(this.PROPS_FILTER))\r\n            func(name, prototype);\r\n    }\r\n    _convertToTemplateExpression(buildFunction) {\r\n        let expression = buildFunction.toString();\r\n        const expressionStart = expression.indexOf('`');\r\n        if (expressionStart > 0)\r\n            expression = expression.substring(expressionStart + 1, expression.length - 1);\r\n        return expression;\r\n    }\r\n    _parseHTML(htmlFunction, locals) {\r\n        const html = this._convertToTemplateExpression(htmlFunction);\r\n        // First call of render?\r\n        if (this._allBindVariables == null)\r\n            this._calculateProperties();\r\n        const allBindVariables = this._allBindVariables;\r\n        const [template, bindVariableNames] = this._calculateTemplateAndBindVariableNames(html, allBindVariables, locals);\r\n        this._calculateBindings(template, bindVariableNames);\r\n        const parser = new DOMParser();\r\n        const elements = parser.parseFromString(template, \"text/html\").body.childNodes;\r\n        return [elements, allBindVariables, bindVariableNames];\r\n    }\r\n    _makeBindVariableObservable(bindVariableName) {\r\n        for (const bindingExpression of this._allBindExpressions[bindVariableName])\r\n            this._makeBindVariableStructureObservable(bindVariableName, bindingExpression);\r\n    }\r\n    _makeBindVariableStructureObservable(bindVariableName, bindingExpression) {\r\n        const o = this._allBindVariables[bindVariableName];\r\n        const props = bindingExpression.split('.');\r\n        let propObj = o;\r\n        let propertyPath = bindVariableName;\r\n        for (let i = 0; i < props.length; i++) {\r\n            let lastProp = props[i];\r\n            propertyPath += `.${props[i]}`;\r\n            if (typeof propObj == \"undefined\")\r\n                return;\r\n            if (typeof propObj == 'object') {\r\n                if (!Array.isArray(propObj))\r\n                    this._makeObjectObservable(propObj, lastProp, bindVariableName, propertyPath);\r\n                else\r\n                    this._makeArrayObservable(propObj, bindVariableName);\r\n            }\r\n            propObj = propObj[props[i]];\r\n        }\r\n    }\r\n    _callBindVariableBeforeChangedHook(obj, prop, newValue, oldValue) {\r\n        const hookMethodName = `${prop}BeforeChanged`;\r\n        if (obj[hookMethodName]) {\r\n            const ret = obj[hookMethodName](newValue, oldValue);\r\n            if (typeof ret != \"undefined\" && ret == false)\r\n                return false;\r\n            return true;\r\n        }\r\n        return true;\r\n    }\r\n    _callBindVariableAfterChangedHook(obj, prop, newValue, oldValue) {\r\n        const hookMethodName = `${prop}AfterChanged`;\r\n        if (obj[hookMethodName])\r\n            obj[hookMethodName](newValue, oldValue);\r\n    }\r\n    _callBindVariableBeforePropertyChangedHook(obj, prop, subProp, newValue, oldValue) {\r\n        const hookMethodName = `${prop}BeforePropertyChanged`;\r\n        if (obj[hookMethodName]) {\r\n            const ret = obj[hookMethodName](subProp, newValue, oldValue);\r\n            if (typeof ret != \"undefined\" && ret == false)\r\n                return false;\r\n            return true;\r\n        }\r\n        return true;\r\n    }\r\n    _callBindVariableAfterPropertyChangedHook(obj, prop, subProp, newValue, oldValue) {\r\n        const hookMethodName = `${prop}AfterPropertyChanged`;\r\n        if (obj[hookMethodName])\r\n            obj[hookMethodName](subProp, newValue, oldValue);\r\n    }\r\n    _makeObjectObservable(obj, observerProperty, componentProperty, propertyPath) {\r\n        let _value = obj[observerProperty];\r\n        const self = this;\r\n        if (this._registerNewObserver(obj, observerProperty)) {\r\n            Object.defineProperty(obj, observerProperty, {\r\n                get: function () { return _value; }.bind(self),\r\n                set: function (v) {\r\n                    const _oldValue = _value;\r\n                    if (self._callBindVariableBeforeChangedHook(obj, observerProperty, v, _oldValue)) {\r\n                        _value = v;\r\n                        obj._observers.forEach((properties, component) => properties.forEach(() => {\r\n                            let bindVariableValue = component.getProperty(componentProperty, undefined);\r\n                            if (bindVariableValue) {\r\n                                if (!component._callBindVariableBeforePropertyChangedHook(self, componentProperty, propertyPath, v, _oldValue)) {\r\n                                    return;\r\n                                }\r\n                                bindVariableValue.lastActionMethod = \"SET\";\r\n                                bindVariableValue.lastActionPropertyPath = propertyPath;\r\n                                component.setProperty(componentProperty, bindVariableValue);\r\n                                component._callBindVariableAfterPropertyChangedHook(self, componentProperty, propertyPath, v, _oldValue);\r\n                                bindVariableValue.lastActionMethod = null;\r\n                                bindVariableValue.lastActionPropertyPath = null;\r\n                            }\r\n                        }));\r\n                        self._callBindVariableAfterChangedHook(obj, observerProperty, _value, _oldValue);\r\n                    }\r\n                }.bind(self),\r\n                enumerable: true,\r\n                configurable: true\r\n            });\r\n        }\r\n    }\r\n    _makeArrayObservable(arr, observerProperty) {\r\n        if (this._registerNewObserver(arr, observerProperty)) {\r\n            arr._emit = function (index, items) {\r\n                // Use partial rendering only for change or delete operations with 1 element\r\n                if (items.length == 0)\r\n                    this.lastActionMethod = \"DELETE\";\r\n                else if (index == null)\r\n                    this.lastActionMethod = \"ADD\";\r\n                else if (items.length == 1)\r\n                    this.lastActionMethod = \"EDIT\";\r\n                this.lastActionIndex = index !== null && index !== void 0 ? index : this.length - 1;\r\n                // Notify observers\r\n                this._observers.forEach((properties, component) => properties.forEach(property => component.setProperty(property, this)));\r\n                // Reset action\r\n                this.lastActionMethod = null;\r\n                this.lastActionIndex = null;\r\n                return this;\r\n            };\r\n            arr.push = function (...items) {\r\n                Array.prototype.push.call(this, ...items);\r\n                arr._emit(null, items);\r\n                return arr.length;\r\n            };\r\n            arr.splice = function (index, deleteCount, ...items) {\r\n                const deletedItems = Array.prototype.splice.call(this, index, deleteCount, ...items);\r\n                if (deleteCount <= 1)\r\n                    arr._emit(index, items);\r\n                return deletedItems;\r\n            };\r\n            arr.edit = function (index, el) { return this.splice(index, 1, el); };\r\n            arr.delete = function (index) { return this.splice(index, 1); };\r\n        }\r\n    }\r\n    _registerNewObserver(obj, observerProperty) {\r\n        if (!obj._observers)\r\n            obj._observers = new Map();\r\n        if (!obj._observers.has(this))\r\n            obj._observers.set(this, []);\r\n        if (!obj._observers.get(this).includes(observerProperty)) {\r\n            obj._observers.get(this).push(observerProperty);\r\n            return true;\r\n        }\r\n        else\r\n            return false;\r\n    }\r\n    _calculateBindings(htmlFunction, bindVariableNames) {\r\n        for (let bindVariableName of bindVariableNames) {\r\n            const regexp = new RegExp(`(${bindVariableName})((\\\\.[\\\\w]+)+)`, 'g');\r\n            this._allBindExpressions[bindVariableName] = [];\r\n            for (const [, , expression] of htmlFunction.matchAll(regexp)) {\r\n                const expr = expression.substring(1);\r\n                if (!this._allBindExpressions[bindVariableName].includes(expr))\r\n                    this._allBindExpressions[bindVariableName].push(expr);\r\n            }\r\n            this._makeBindVariableObservable(bindVariableName);\r\n        }\r\n    }\r\n    _renderFull(htmlFunction, locals) {\r\n        this._locals = locals;\r\n        const [elements, bindVariables, bindVariableNames] = this._parseHTML(htmlFunction, locals);\r\n        const lastExistingElement = this._root.childNodes.length;\r\n        while (elements.length > 0) // Elements are extracted from source at appendChild, therefore always first element\r\n            this._root.appendChild(elements[0]);\r\n        // Incrementally process only those elements recursively that have not been processed via\r\n        // previous renderList or renderContent method within the same render method, so that the\r\n        // same elements are not processed multiple times and added to the observables data structure.\r\n        for (let index = lastExistingElement; index < this._root.childNodes.length; index++)\r\n            this._processElementBinding(this._root.childNodes[index], bindVariables, bindVariableNames);\r\n    }\r\n    _renderUpdate(newBindVariableValue) {\r\n        // Only partially update components that render list, since for other components\r\n        // other element would be added/deleted\r\n        if (this._listTemplate != null) {\r\n            this._locals[this._listIt] = this._listData[newBindVariableValue.lastActionIndex];\r\n            const [elements, bindVariables, bindVariableNames] = this._parseHTML(this._listTemplate, { [this._listIt]: this._listData[newBindVariableValue.lastActionIndex] });\r\n            if (newBindVariableValue.lastActionMethod == \"ADD\") {\r\n                if (this._root.childNodes[newBindVariableValue.lastActionIndex])\r\n                    this._root.insertBefore(elements[0], this._root.childNodes[this._listStart + newBindVariableValue.lastActionIndex - 1].nextSibling);\r\n                else\r\n                    this._root.appendChild(elements[0]);\r\n                this._processElementBinding(this._root.childNodes[this._listStart + newBindVariableValue.lastActionIndex], bindVariables, bindVariableNames);\r\n            }\r\n            else if (newBindVariableValue.lastActionMethod == \"EDIT\") {\r\n                this._root.replaceChild(elements[0], this._root.childNodes[this._listStart + newBindVariableValue.lastActionIndex]);\r\n                this._processElementBinding(this._root.childNodes[this._listStart + newBindVariableValue.lastActionIndex], bindVariables, bindVariableNames);\r\n            }\r\n            else if (newBindVariableValue.lastActionMethod == \"DELETE\")\r\n                this._root.childNodes[this._listStart + newBindVariableValue.lastActionIndex].remove();\r\n        }\r\n    }\r\n    _makeDerivedVariablesObservable(variableName, variableBody, html) {\r\n        // Nur global in der Form prop: function() bzw. lokal in der Form prop = function()\r\n        // definierte abgeleitete Properties observable machen (keine regul\u00E4ren Methoden / Funktionen\r\n        // in der Form function name() bzw. name())\r\n        if (!this.DERIVED_PROPERTY_SIGNATURE_REGEX.test(variableBody))\r\n            return html;\r\n        // Make derived bind variables observable\r\n        let referencedBindVariableNames = \"||null\";\r\n        for (const [referencedBindVariableName] of variableBody.matchAll(this.REFERENCED_BIND_VARIABLE_NAMES_REGEX))\r\n            referencedBindVariableNames += \"||\" + referencedBindVariableName;\r\n        return html.replaceAll(`${variableName}`, `(${variableName}()${referencedBindVariableNames})`);\r\n    }\r\n    _calculateTemplateAndBindVariableNames(html, props, locals) {\r\n        this._renderIteration++;\r\n        // Determine all binding variables\r\n        const bindVariables = Object.keys(props);\r\n        // Add additional local variables to binding\r\n        if (locals) {\r\n            for (let [n, v] of Object.entries(locals)) {\r\n                const uniqueBindVariableName = n + this._renderIteration;\r\n                props[uniqueBindVariableName] = v;\r\n                bindVariables.push(uniqueBindVariableName);\r\n                const regexp = new RegExp(`(${n.replaceAll(\"$\", \"\\\\$\")})([^=-])`, 'g');\r\n                for (const [expr, , token] of html.matchAll(regexp))\r\n                    html = html.replace(expr, `${uniqueBindVariableName}${token}`);\r\n                html = this._makeDerivedVariablesObservable(uniqueBindVariableName, v.toString(), html);\r\n            }\r\n        }\r\n        // Make derived global bind variables observable\r\n        const regexp = new RegExp('(this[\\\\w$.]*\\\\.[\\\\w$]+)([(]?)', 'g');\r\n        for (const [, expr, token] of html.matchAll(regexp)) {\r\n            if (token == '(')\r\n                continue;\r\n            // Resolve property variable (defined in componented or referenced from store)\r\n            const index = expr.indexOf(\".\") + 1;\r\n            const functionBody = new Function(\"return \" + expr).call(props).toString().replaceAll(\"this.\", expr.substring(index, expr.indexOf(\".\", index) + 1));\r\n            html = this._makeDerivedVariablesObservable(expr, functionBody, html);\r\n        }\r\n        return [html, bindVariables];\r\n    }\r\n    _processElementBinding(element, bindVariables, bindVariableNames) {\r\n        // Support databinding expressions in attributes (regular DOM elements)\r\n        if (\"attributes\" in element)\r\n            Array.from(element.attributes).forEach((attr) => {\r\n                if (attr.nodeValue.includes(\"${\"))\r\n                    this._processBindingExpression(element, bindVariables, bindVariableNames, attr.nodeName, attr.nodeValue);\r\n            });\r\n        // Support databinding expressions within tags (TextNodes)\r\n        if (\"data\" in element) {\r\n            if (element.data.includes(\"${\"))\r\n                this._processBindingExpression(element, bindVariables, bindVariableNames, \"data\", element.data);\r\n        }\r\n        // Edit child elements recursively\r\n        if (\"childNodes\" in element)\r\n            for (const childElement of Array.from(element.childNodes)) {\r\n                this._processElementBinding(childElement, bindVariables, bindVariableNames);\r\n            }\r\n        // Render elements with render support      \r\n        if (\"_hasAlreadyRendered\" in element && !element._hasAlreadyRendered())\r\n            element.render();\r\n    }\r\n    _processBindingExpression(element, bindVariables, bindVariableNames, attr, expr) {\r\n        // Build callable expression to (re)calculate value of attribute based on depending binding variables  \r\n        const attributeExpression = this._buildCallableExpression(attr, expr, bindVariableNames);\r\n        // Save attribute expression for later execution on bind variable changes\r\n        if (!this._observerExpressions.has(element))\r\n            this._observerExpressions.set(element, new Map());\r\n        this._observerExpressions.get(element).set(attr, attributeExpression);\r\n        // Register combination of element and attribute as observer for each bind variable name\r\n        this._registerElementAttributeAsObserverForBindVariables(element, attr, bindVariables, attributeExpression.bindVariableNames);\r\n        // Determine current values\r\n        const bindVariableValues = this._getBindVariableValues(attributeExpression.bindVariableNames);\r\n        // Get current value of element attribute by evaluating expression\r\n        element[attr] = attributeExpression.execute(...bindVariableValues);\r\n    }\r\n    _buildCallableExpression(attr, expr, bindVariableNames) {\r\n        // If expression is the only expression, do not interpret it as string,\r\n        // but evaluate directly so that references to functions can be assigned to properties\r\n        if (attr == \"data\" || expr.lastIndexOf(\"${\") > 0 || expr.lastIndexOf(\"}\") < expr.length - 1)\r\n            expr = \"`\" + expr + \"`\";\r\n        else\r\n            expr = expr.replaceAll(\"${\", \"\").replaceAll(\"}\", \"\");\r\n        let referencedBindVariables = [];\r\n        for (const bindVariableName of bindVariableNames) {\r\n            if (expr.includes(bindVariableName))\r\n                referencedBindVariables.push(bindVariableName);\r\n        }\r\n        // Currently, in addition to the local variables (additional variables passed to renderContent/renderList),\r\n        // the WebComponent's properties are also passed as local variables to the WebComponent's attribute function,\r\n        // which is not really necessary, but facilitates the generic handling\r\n        return new AttributeExpression(new Function(...referencedBindVariables, \"return \" + expr).bind(this), referencedBindVariables, expr);\r\n    }\r\n    _registerElementAttributeAsObserverForBindVariables(element, attr, bindVariables, referencedBindVariableNames) {\r\n        // Add combination of element and attribute to observer structure\r\n        for (let bindVariableName of referencedBindVariableNames) {\r\n            if (!this._observersForBindVariable.has(bindVariableName))\r\n                this._observersForBindVariable.set(bindVariableName, new Map());\r\n            const variableObservable = this._observersForBindVariable.get(bindVariableName);\r\n            if (!variableObservable.has(element))\r\n                variableObservable.set(element, []);\r\n            if (bindVariables[bindVariableName].bind)\r\n                bindVariables[bindVariableName] = bindVariables[bindVariableName].bind(this); // this von Parent an Child mitgeben bei nach unten gereichten Callbacks\r\n            variableObservable.get(element).push(attr);\r\n        }\r\n    }\r\n    _getBindVariableValues(bindVariableNames) {\r\n        let result = [];\r\n        for (const b of bindVariableNames)\r\n            result.push(this._allBindVariables[b]);\r\n        return result;\r\n    }\r\n    _updatePropertyObservers(bindVariable) {\r\n        const [bindVariableName, bindVariableValue] = bindVariable;\r\n        // Render partially only if element has already been created.\r\n        // (Setters should also be able to be called before component\r\n        // has been created for the first time, which is why state setters\r\n        // only change state here, but have no effect on UI yet).\r\n        if (this._observersForBindVariable.has(bindVariableName)) {\r\n            for (const [element, attrs] of this._observersForBindVariable.get(bindVariableName).entries()) {\r\n                for (const attrName of attrs) {\r\n                    const attrExpr = this._observerExpressions.get(element).get(attrName);\r\n                    // Reevaluate binding expression\r\n                    const bindVariableValues = this._getBindVariableValues(attrExpr.bindVariableNames);\r\n                    const newValue = attrExpr.execute(...bindVariableValues);\r\n                    // Always propagate changes in properties to all observer elements and\r\n                    // propagate changes in subproperties only if subproperty is included in binding expression / template\r\n                    // (e.g. if data.selectedPerson.name is changed, only attributes with bindings to data, data.selectedPerson\r\n                    // and data.selectedPerson.name, but e.g. not on data.selectedPerson.age).\r\n                    if (!bindVariableValue.lastActionPropertyPath || attrExpr.template && attrExpr.template.includes(bindVariableValue.lastActionPropertyPath)) {\r\n                        // Partielle Updates bei Collections triggern\r\n                        if (newValue.lastActionMethod) {\r\n                            if (element instanceof HofHtmlElement)\r\n                                element._renderUpdate(newValue);\r\n                            // console.log(`[${element.tagName ?? \"TEXT\"}] Partial update of ${attrName}: ${newValue.lastActionMethod} ${JSON.stringify(newValue[newValue.lastActionIndex])}`);\r\n                        }\r\n                        else {\r\n                            element[attrName] = newValue;\r\n                            // console.log(`[${element.tagName ?? \"TEXT\"}]: Full update of ${attrName}: ${JSON.stringify(newValue)}`);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n// Helper function to support functional component definition as alternative to class based web component implementation\r\nexport function component(name, obj, tag = \"div\") {\r\n    let componentConstructor = class extends HofHtmlElement {\r\n        constructor() { super(tag); super.useAutoProps(); }\r\n        render() { }\r\n    };\r\n    componentConstructor[\"componentName\"] = name;\r\n    for (const prop of Object.keys(obj))\r\n        if (prop == \"render\") {\r\n            const func = obj[prop]();\r\n            const variables = _calculateLocalVariables(prop);\r\n            delete componentConstructor[\"render\"];\r\n            if (Array.isArray(func)) {\r\n                const renderFuncs = [];\r\n                if (func.length > 0 && Array.isArray(func[0])) // Array mit Render-Funktionen\r\n                    for (const renderExpr of func)\r\n                        renderFuncs.push(_calculateRenderFunc(renderExpr));\r\n                else\r\n                    renderFuncs.push(_calculateRenderFunc(func));\r\n                componentConstructor.prototype[\"render\"] = function () { renderFuncs.forEach((renderFunc => renderFunc(this, variables))); };\r\n            }\r\n            else // Call function\r\n                componentConstructor.prototype[\"render\"] = function () { this.renderContent(func, variables); };\r\n        }\r\n        else {\r\n            // Due to a bug in current JS implementations, DOM events are also executed when the getter is\r\n            // accessed, which leads to errors if DOM element / web component is not yet inserted in the\r\n            // real DOM, so that the onXY events are stored here under a different name and later\r\n            // registered within the class under the correct name (this works because the custom element\r\n            // has already been registered than)\r\n            componentConstructor.prototype[\"event-\" + prop] = obj[prop];\r\n        }\r\n    function _calculateRenderFunc(func) {\r\n        if (func.length == 1) // Call [function]\r\n            return function (obj, variables) { obj.renderContent(func[0], variables); };\r\n        else if (func.length == 2 && typeof (func[0]) == \"function\") // Call [function, variables]\r\n            return function (obj) { obj.renderContent(func[0], func[1]); };\r\n        else if (func.length >= 2 && typeof (func[1]) == \"function\") // Call [listVariable, function, variables]\r\n            return function (obj, variables) { var _a, _b; obj.renderList((_a = obj[func[0]]) !== null && _a !== void 0 ? _a : func[0], func[1], (_b = func[2]) !== null && _b !== void 0 ? _b : variables); };\r\n        else\r\n            throw new Error(\"Invalid render function argument!\");\r\n    }\r\n    function _calculateLocalVariables(prop) {\r\n        let functionDefinition = obj[prop].toString();\r\n        let begin = functionDefinition.indexOf(\"{\") + 1;\r\n        let end = functionDefinition.lastIndexOf(\"return\");\r\n        let functionBody = functionDefinition.substring(begin, end);\r\n        // Filter out comments\r\n        functionBody = functionBody.replace(/\\/\\*[\\s\\S]*?\\*\\/|([^:]|^)\\/\\/.*$/gm, ' ');\r\n        // Calculate variable names\r\n        const regexps = [\r\n            new RegExp(`let[^\\\\w$]+([\\\\w$]+)[\\\\W]*=`, 'g'),\r\n            new RegExp(`const[^\\\\w$]+([\\\\w$]+)[\\\\W]*=`, 'g'),\r\n            new RegExp(`function[^\\\\w$]+([\\\\w$]+)\\\\(`, 'g')\r\n        ];\r\n        const variables = [];\r\n        for (const regexp of regexps)\r\n            for (const [, variable] of functionBody.matchAll(regexp))\r\n                variables.push(variable);\r\n        // Calculate variable values\r\n        if (variables.length > 0)\r\n            return new Function(functionBody + \"return {\" + variables.join(\",\") + \"}\").call(obj);\r\n        else\r\n            return [];\r\n    }\r\n    customElements.define(name, componentConstructor);\r\n    return componentConstructor;\r\n}\r\n", "import { HofHtmlElement } from \"@hofjs/hofjs/lib/esm/hof\";\r\n\r\ninterface RoutesConfig {\r\n    [routeName: string]: RouteConfig\r\n}\r\n\r\ninterface RouteConfig {\r\n    url: string;\r\n    component: new() => HofHtmlElement;\r\n    params: Object;\r\n    redirect: string;\r\n    aliases: string[];\r\n}\r\n\r\ninterface Routes {\r\n    [routeName: string]: Route\r\n}\r\n\r\ninterface Route extends RouteConfig {\r\n    urlRegex: RegExp,\r\n    aliasesRegexes: RegExp[];\r\n    renderElementParent: ShadowRoot;\r\n    renderElementId: string;\r\n}\r\n\r\ninterface RouteInfo {\r\n    url: string;\r\n    query: string;\r\n    params: Object;\r\n}\r\n\r\ninterface UrlParams {\r\n    [routeName: string]: string\r\n}\r\n\r\nexport class HofRouter {\r\n    static initialized: boolean = false;\r\n    static routes: Routes = {};\r\n    static defaultRoute: Route = null;\r\n    static current: RouteInfo = null;\r\n\r\n    static _setup() {\r\n        HofRouter.initialized = true;\r\n        window.onload = () => {                 \r\n            HofRouter.processRoute(document.location.href, true, false);\r\n\r\n            document.body.addEventListener('click', function(e: MouseEvent) {\r\n                const el = e[\"path\"][0];\r\n                if (el.nodeName == 'A') {\r\n                    e.preventDefault();\r\n                    HofRouter.processRoute(el.attributes[0].nodeValue);\r\n                }\r\n            });\r\n        }\r\n        window.onpopstate = (event: PopStateEvent) => { HofRouter.processRoute(event.state.url, false, false);}\r\n    }\r\n\r\n    static _buildRoute(renderElementParent: ShadowRoot, renderElementId: string, config: RouteConfig): Route {\r\n        return {\r\n            url: config.url,\r\n            urlRegex: calculatePathExpression(config.url), // Support shortcut parameter syntax :param\r\n            component: config.component,\r\n            params: config.params,\r\n            redirect: config.redirect,\r\n            aliases: config.aliases,\r\n            aliasesRegexes: config.aliases?.map(alias => calculatePathExpression(alias)),\r\n            renderElementParent, renderElementId\r\n        };\r\n\r\n        function calculatePathExpression(path: string): RegExp {\r\n            if (path == \"*\")\r\n                return new RegExp(\"^.*$\");\r\n\r\n            return new RegExp(\"^\" + path.replace(/:([a-zA-Z0-9]+)/, \"(?<$1>[\\\\w-]+)\") + \"(\\\\?(?<$routeQuery>.*))?$\");\r\n        }\r\n    }\r\n\r\n    static configRoutes(renderElementParent: ShadowRoot, renderElementId: string, routeEntries: RoutesConfig) {\r\n        if (!HofRouter.initialized) HofRouter._setup();\r\n\r\n        for (const [name, config] of Object.entries(routeEntries)) {\r\n            const route = HofRouter._buildRoute(renderElementParent, renderElementId, config);\r\n\r\n            if (config.url == \"*\") HofRouter.defaultRoute = route;\r\n            else HofRouter.routes[name] = route;\r\n        }\r\n    }\r\n\r\n    static _findCurrentView(mountElement: HTMLElement): HofHtmlElement {\r\n        for (const child of Array.from(mountElement.children))\r\n            if (child[\"style\"] && child[\"style\"].display != 'none')\r\n                return child as HofHtmlElement;\r\n\r\n        return null;\r\n    }\r\n\r\n    static _findNextView(mountElement: HTMLElement, route: Route): HofHtmlElement {\r\n        for (const child of Array.from(mountElement.children))\r\n            if (child instanceof HofHtmlElement && child.getAttribute(\"router-url\") == route.url)\r\n                return child;\r\n\r\n        return null;\r\n    }\r\n\r\n    static _updateView(view: HofHtmlElement, route: Route, urlParams: UrlParams) {\r\n        // Initialize component with configured parameters\r\n        for (const param in route.params)\r\n            view[param] = route.params[param];\r\n\r\n        // Build injectable route object\r\n        const routeInfo = { url: route.url, params: {}, query: \"\" };\r\n        for (const param in urlParams) {                             \r\n            if (param == \"$routeQuery\") {\r\n                if (typeof urlParams[param] != 'undefined') {\r\n                    for (const paramExpr of urlParams[param].split(\"&\")) {\r\n                        const paramNameAndValue = paramExpr.split(\"=\");\r\n                        if (paramNameAndValue.length == 2)\r\n                        routeInfo.params[paramNameAndValue[0]] = paramNameAndValue[1];\r\n                    }\r\n\r\n                    routeInfo.query = urlParams[param];\r\n                }\r\n            }\r\n            else\r\n                view[param] = urlParams[param];\r\n        }\r\n\r\n        HofRouter.current = routeInfo;\r\n         \r\n        view.setAttribute(\"router-url\", route.url);\r\n    }\r\n\r\n    static _loadView(mountElement: HTMLElement, route: Route, urlParams: UrlParams) {\r\n        const view = new route.component();\r\n        \r\n        // View should be initially hidden\r\n        view.style.display = 'none';\r\n\r\n        HofRouter._updateView(view, route, urlParams);\r\n\r\n        mountElement.appendChild(view);\r\n\r\n        return view;\r\n    }\r\n\r\n    static _callBeforeRoutingHook(view: HofHtmlElement, nextUrl: string, currentUrl: string) {\r\n        if (view != null && view[\"beforeRouting\"]) {\r\n            const ret = view[\"beforeRouting\"](nextUrl, currentUrl);\r\n            if (typeof ret != \"undefined\" && ret == false)\r\n                return false; \r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    static _callAfterRoutingHook(view: HofHtmlElement, nextUrl: string, currentUrl: string) {\r\n        if (view != null && view[\"afterRouting\"])\r\n            view[\"afterRouting\"](nextUrl, currentUrl);\r\n    }\r\n\r\n    static _resolveRouterUrl(url: string) {\r\n        // Sample: <a href=\"router:pageDetails(id=1, param1=Hello, param2=World)\">Details 3</a>\r\n\r\n        const paramsStartIndex = url.indexOf(\"(\");\r\n        const paramsEndIndex = url.indexOf(\")\");\r\n        const routeName = paramsStartIndex == -1 ? url.substring(7) : url.substring(7, paramsStartIndex);\r\n        const parametersExpr = paramsStartIndex == -1 ? \"\" : url.substring(paramsStartIndex+1, paramsEndIndex);\r\n\r\n        // Resolve integrated router functions\r\n        if (routeName == \"back\") { HofRouter.back(); return null; }\r\n        else if (routeName == \"forward\") { HofRouter.forward(); return null; }\r\n        else if (routeName == \"go\") { HofRouter.go(parseInt(parametersExpr)); return null; }\r\n        else if (routeName == \"push\") { HofRouter.push(parametersExpr); return null; }\r\n        else if (routeName == \"replace\") { HofRouter.replace(parametersExpr); return null; }\r\n\r\n        let resolvedUrl = HofRouter.routes[routeName].url;\r\n        let resolvedUrlQuery = \"?\";\r\n\r\n        if (parametersExpr)\r\n            for (const param of parametersExpr.split(\",\")) {\r\n                let [name, value] = param.trim().split(\"=\");\r\n                \r\n                if (resolvedUrl.includes(`:${name}`))\r\n                    resolvedUrl = resolvedUrl.replace(`:${name}`, value);\r\n                else\r\n                    resolvedUrlQuery += `${name}=${value}&`;\r\n            }\r\n        resolvedUrlQuery = resolvedUrlQuery.substring(0, resolvedUrlQuery.length-1);\r\n        resolvedUrl += resolvedUrlQuery;\r\n\r\n        return resolvedUrl;\r\n    }\r\n\r\n    static _matchRoute(nextUrl: string, route: Route, updateHistory: boolean, addMode: boolean) {\r\n        if (nextUrl.startsWith(\"router:\")) {\r\n            nextUrl = HofRouter._resolveRouterUrl(nextUrl);\r\n            \r\n            // Router action already processed, i.e. no nextUrl\r\n            if (nextUrl == null) return true;\r\n        }\r\n\r\n        const match = route.urlRegex.exec(nextUrl)\r\n            ?? route.aliasesRegexes?.map(alias => alias.exec(nextUrl)).find(alias => alias != null);\r\n\r\n        if (match != null) {\r\n            if (route.redirect) return true;\r\n\r\n            const mountElement = route.renderElementParent.getElementById(route.renderElementId);\r\n            const currentViewComponent = HofRouter._findCurrentView(mountElement);\r\n            const currentUrl = currentViewComponent?.getAttribute(\"router-url\");\r\n            const urlParams = match.groups;\r\n            const nextViewComponent = HofRouter._findNextView(mountElement, route)\r\n                ?? HofRouter._loadView(mountElement, route, urlParams);\r\n\r\n            HofRouter._callBeforeRoutingHook(currentViewComponent, nextUrl, currentUrl);\r\n            HofRouter._callBeforeRoutingHook(nextViewComponent, nextUrl, currentUrl);\r\n\r\n            if (currentViewComponent)\r\n                currentViewComponent.style.display = 'none';\r\n            nextViewComponent.style.display = '';\r\n\r\n            HofRouter._updateView(nextViewComponent, route, urlParams);\r\n\r\n            if (updateHistory) {\r\n                if (addMode) history.pushState({ url: nextUrl }, \"\", nextUrl);                       \r\n                else history.replaceState({ url: nextUrl }, \"\", nextUrl);                            \r\n            }\r\n\r\n            HofRouter._callAfterRoutingHook(currentViewComponent, nextUrl, currentUrl);\r\n            HofRouter._callAfterRoutingHook(nextViewComponent, nextUrl, currentUrl);\r\n            \r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    static processRoute(nextUrl: string, updateHistory: boolean = true, addMode: boolean = true) {\r\n        // Try to match against regular routes\r\n        for (const route of Object.values(HofRouter.routes)) {\r\n            if (HofRouter._matchRoute(nextUrl, route, updateHistory, addMode)) {\r\n                if (route.redirect)\r\n                    HofRouter.processRoute(route.redirect, updateHistory, addMode);\r\n\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Try to match against default route\r\n        if (HofRouter.defaultRoute && HofRouter._matchRoute(nextUrl, HofRouter.defaultRoute, updateHistory, addMode)) {\r\n            if (HofRouter.defaultRoute.redirect)\r\n                HofRouter.processRoute(HofRouter.defaultRoute.redirect, updateHistory, addMode);\r\n\r\n            return;\r\n        }\r\n\r\n        // No matching route found\r\n        throw Error(`No matching route definition to resolve url ${nextUrl}!`);\r\n    }\r\n\r\n    static back() { history.back(); }\r\n    static forward() { history.forward(); }\r\n    static go(delta: number) { history.go(delta); }\r\n    static push(url: string) { HofRouter.processRoute(url, true, true); }\r\n    static replace(url: string) { HofRouter.processRoute(url, true, false); }\r\n}", "// File, which is used to import library via regular import mechanism\r\n// but then adding imported entities to the window object\r\n// so that even without modules the JavaScript code will be executed\r\n// and can be used directly in a web application (this file is used\r\n// by esbuild to create nomodule version of this library)\r\n\r\n// Import elements of library\r\nimport { HofRouter } from '../hofrouter'\r\n\r\n// Make elements of library accessible on the window object\r\n(window as any).HofRouter = HofRouter;"],
  "mappings": "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",
  "names": []
}
