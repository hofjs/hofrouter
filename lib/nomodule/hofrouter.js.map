{
  "version": 3,
  "sources": ["../../node_modules/@hofjs/hofjs/lib/esm/hof.js", "../../src/hofrouter.ts", "../../src/esbuild-wrapper/hofrouter.esbuild.ts"],
  "sourcesContent": ["// https://github.com/prateek3255/typescript-react-demo-library\r\nclass AttributeExpression {\r\n    constructor(execute, bindVariableNames, template) {\r\n        this.execute = execute;\r\n        this.bindVariableNames = bindVariableNames;\r\n        this.template = template;\r\n    }\r\n}\r\n// Base class for all Web components created by this framework\r\nexport class HofHtmlElement extends HTMLElement {\r\n    constructor(tagName = 'div') {\r\n        super();\r\n        this._properties = {}; // Global properties (of component)\r\n        this._locals = {}; // Local variables (of render function), including list iteration variables such as person0, person1, ...\r\n        this._allBindVariables = null; // All bind variables, derived from properties and locals\r\n        this._allBindExpressions = {}; // All bind variable expressions used in templates\r\n        this._observersForBindVariable = new Map(); // Map<BindVariableName, Map<DOMElement, AttributeName[]>>\r\n        this._observerExpressions = new Map(); // Map<DOMElement, Map<AttributeName, AttributeExpression>>\r\n        this._renderIteration = -1; // Each rendering process increments id (rendering of a list of n elements means n incrementations, each update an additional one)\r\n        this._listTemplate = null;\r\n        this._listData = [];\r\n        this._listIt = \"\";\r\n        this._listStart = 0;\r\n        this.PROPS_FILTER = (p) => p.charAt(0) != '_' && p != p.toUpperCase() && p != 'constructor' && p != 'render';\r\n        this.REFERENCED_BIND_VARIABLE_NAMES_REGEX = new RegExp('([a-zA-Z_$][\\\\w]+\\\\.[\\\\w\\\\.]+)', 'g');\r\n        this.DERIVED_PROPERTY_SIGNATURE_REGEX = new RegExp(\"^function *\\\\(\\\\)\");\r\n        this._tagName = tagName;\r\n        this._shadow = this.attachShadow({ mode: \"open\" });\r\n    }\r\n    connectedCallback() {\r\n        this._root = document.createElement(this._tagName);\r\n        this._shadow.appendChild(this._root);\r\n        this.render();\r\n    }\r\n    useAutoProps() {\r\n        // Replace all public simple properties with getters and setters,\r\n        // so that access can be intercepted and observability can be realized\r\n        this._forEachPropertyOfObjectAndPrototype((prop, obj) => {\r\n            const initialValue = obj[prop];\r\n            // Fix for event handlers because they cannot be added with defineProperty\r\n            // from component() as long as a web component is not part of the DOM\r\n            if (prop.startsWith(\"event-\")) {\r\n                prop = prop.substring(6);\r\n                delete obj[prop];\r\n            }\r\n            if (prop == \"construct\" && typeof (initialValue) == \"function\") {\r\n                initialValue.call(this);\r\n            }\r\n            else // Default Property handling\r\n                Object.defineProperty(this, prop, {\r\n                    get: function () { return this.getProperty(prop, initialValue); },\r\n                    set: function (v) {\r\n                        const oldValue = this.getProperty(prop, initialValue);\r\n                        if (this._callBindVariableBeforeChangedHook(this, prop, v, oldValue)\r\n                            && this._callBindVariableBeforePropertyChangedHook(this, prop, \"\", v, oldValue)) {\r\n                            // If not initial rendering (oldValue != undefined) and value set on\r\n                            // initial rendering is array, make partial update instead of full update\r\n                            if (Array.isArray(oldValue))\r\n                                this._renderUpdate(v);\r\n                            else\r\n                                this.setProperty(prop, v);\r\n                            this._callBindVariableAfterPropertyChangedHook(this, prop, \"\", v, oldValue);\r\n                            this._callBindVariableAfterChangedHook(this, prop, v, oldValue);\r\n                        }\r\n                    },\r\n                    enumerable: true,\r\n                    configurable: true\r\n                });\r\n        });\r\n    }\r\n    setProperty(name, value) {\r\n        const oldValue = this._properties[name];\r\n        // Render again in case of complex object or on value change of simple property or on collection action\r\n        if (typeof (oldValue) == \"object\" || typeof (value) == \"object\" || oldValue != value || value[\"lastActionMethod\"]) {\r\n            // Only update property if it was changed and not only subproperty\r\n            if (!value.lastActionPropertyPath) {\r\n                // Process initial element-property setter calls (cache for time after template\r\n                // has been constructed and further binding variables are available)\r\n                this._properties[name] = value;\r\n                // Update properties including local binding variables\r\n                if (this._allBindVariables)\r\n                    this._allBindVariables[name] = value;\r\n                // Make new objects observable\r\n                if (this._allBindVariables)\r\n                    this._makeBindVariableObservable(name);\r\n            }\r\n        }\r\n        this._updatePropertyObservers([name, value]);\r\n    }\r\n    getProperty(name, initialValue) {\r\n        var _a, _b;\r\n        if (this._allBindVariables)\r\n            return this._allBindVariables[name];\r\n        return (_b = (_a = this._properties[name]) !== null && _a !== void 0 ? _a : this.getAttribute(name)) !== null && _b !== void 0 ? _b : initialValue;\r\n    }\r\n    _hasAlreadyRendered() {\r\n        return this._root.textContent != \"\";\r\n    }\r\n    renderContent(html, locals = undefined) {\r\n        this._renderFull(html, locals);\r\n    }\r\n    renderList(data, html, locals = undefined) {\r\n        const expression = html.toString();\r\n        const listIt = expression.substring(expression.indexOf('(') + 1, expression.indexOf(')'));\r\n        // List not yet resolved at time of call (first rendering), i.e. still value like ${data}\r\n        if (typeof data == \"string\")\r\n            return;\r\n        this._listData = data;\r\n        this._listIt = listIt;\r\n        this._listTemplate = html;\r\n        this._listStart = this._root.childNodes.length;\r\n        if (typeof (locals) == \"undefined\" || locals == null)\r\n            locals = {};\r\n        for (const listItem of this._listData) {\r\n            locals[this._listIt] = listItem;\r\n            locals[this._listIt]._observableUniqueName = this._listIt + (this._renderIteration + 1);\r\n            this._renderFull(html, locals);\r\n        }\r\n    }\r\n    _calculateProperties() {\r\n        let result = {};\r\n        this._forEachPropertyOfObjectAndPrototype((prop, obj) => result[prop] = obj[prop]);\r\n        this._allBindVariables = result;\r\n    }\r\n    _forEachPropertyOfObjectAndPrototype(func) {\r\n        for (const name of Object.getOwnPropertyNames(this).filter(this.PROPS_FILTER))\r\n            func(name, this);\r\n        const prototype = Object.getPrototypeOf(this);\r\n        for (const name of Object.getOwnPropertyNames(prototype).filter(this.PROPS_FILTER))\r\n            func(name, prototype);\r\n    }\r\n    _convertToTemplateExpression(buildFunction) {\r\n        let expression = buildFunction.toString();\r\n        const expressionStart = expression.indexOf('`');\r\n        if (expressionStart > 0)\r\n            expression = expression.substring(expressionStart + 1, expression.length - 1);\r\n        return expression.trim();\r\n    }\r\n    _parseHTML(htmlFunction, locals) {\r\n        const html = this._convertToTemplateExpression(htmlFunction);\r\n        // First call of render?\r\n        if (this._allBindVariables == null)\r\n            this._calculateProperties();\r\n        const allBindVariables = this._allBindVariables;\r\n        const [template, bindVariableNames] = this._calculateTemplateAndBindVariableNames(html, allBindVariables, locals);\r\n        this._calculateBindings(template, bindVariableNames);\r\n        const parser = new DOMParser();\r\n        const elements = parser.parseFromString(template, \"text/html\").body.childNodes;\r\n        return [elements, allBindVariables, bindVariableNames];\r\n    }\r\n    _makeBindVariableObservable(bindVariableName) {\r\n        for (const bindingExpression of this._allBindExpressions[bindVariableName])\r\n            this._makeBindVariableStructureObservable(bindVariableName, bindingExpression);\r\n    }\r\n    _makeBindVariableStructureObservable(bindVariableName, bindingExpression) {\r\n        const o = this._allBindVariables[bindVariableName];\r\n        const props = bindingExpression.split('.');\r\n        let propObj = o;\r\n        let propertyPath = bindVariableName;\r\n        for (let i = 0; i < props.length; i++) {\r\n            let lastProp = props[i];\r\n            propertyPath += `.${props[i]}`;\r\n            if (typeof propObj == \"undefined\")\r\n                return;\r\n            if (typeof propObj == 'object') {\r\n                if (!Array.isArray(propObj) && propertyPath.includes(\".\") && propObj[lastProp].bind) {\r\n                    propObj[lastProp] = propObj[lastProp].bind(propObj);\r\n                }\r\n                // Do not observe function references\r\n                if (propObj[lastProp][\"bind\"])\r\n                    continue;\r\n                // Observe arrays and objects\r\n                if (!Array.isArray(propObj))\r\n                    this._makeObjectObservable(propObj, lastProp, bindVariableName, propertyPath);\r\n                else {\r\n                    this._makeArrayObservable(propObj, lastProp, bindVariableName, propertyPath);\r\n                }\r\n            }\r\n            propObj = propObj[props[i]];\r\n        }\r\n    }\r\n    _callBindVariableBeforeChangedHook(obj, prop, newValue, oldValue) {\r\n        const hookMethodName = `${prop}BeforeChanged`;\r\n        if (obj[hookMethodName]) {\r\n            const ret = obj[hookMethodName](newValue, oldValue);\r\n            if (typeof ret != \"undefined\" && ret == false)\r\n                return false;\r\n            return true;\r\n        }\r\n        return true;\r\n    }\r\n    _callBindVariableAfterChangedHook(obj, prop, newValue, oldValue) {\r\n        const hookMethodName = `${prop}AfterChanged`;\r\n        if (obj[hookMethodName])\r\n            obj[hookMethodName](newValue, oldValue);\r\n    }\r\n    _callBindVariableBeforePropertyChangedHook(obj, prop, subProp, newValue, oldValue) {\r\n        const hookMethodName = `${prop}BeforePropertyChanged`;\r\n        if (obj[hookMethodName]) {\r\n            const ret = obj[hookMethodName](subProp, newValue, oldValue);\r\n            if (typeof ret != \"undefined\" && ret == false)\r\n                return false;\r\n            return true;\r\n        }\r\n        return true;\r\n    }\r\n    _callBindVariableAfterPropertyChangedHook(obj, prop, subProp, newValue, oldValue) {\r\n        const hookMethodName = `${prop}AfterPropertyChanged`;\r\n        if (obj[hookMethodName])\r\n            obj[hookMethodName](subProp, newValue, oldValue);\r\n    }\r\n    _makeObjectObservable(obj, observerProperty, componentProperty, propertyPath) {\r\n        let _value = obj[observerProperty];\r\n        const self = this;\r\n        if (!this._registerNewObserver(obj, observerProperty, this, componentProperty, propertyPath)) {\r\n            Object.defineProperty(obj, observerProperty, {\r\n                get: function () { return _value; }.bind(this),\r\n                set: function (v) {\r\n                    const newValue = v;\r\n                    const oldValue = obj[observerProperty];\r\n                    self._applyValueAndNotifyObservers(obj, observerProperty, componentProperty, newValue, oldValue, false, () => _value = v);\r\n                }.bind(this),\r\n                enumerable: true,\r\n                configurable: true\r\n            });\r\n            // Adapt binding for methods in properties, so methods use this of surrounding object literal\r\n            if (propertyPath.includes(\".\") && obj[observerProperty].bind) {\r\n                obj[observerProperty] = obj[observerProperty].bind(obj);\r\n            }\r\n        }\r\n    }\r\n    _makeArrayObservable(arr, observerProperty, componentProperty, propertyPath) {\r\n        const self = this;\r\n        if (!this._registerNewObserver(arr, observerProperty, this, componentProperty, propertyPath)) {\r\n            arr._emit = function (index, items, deletedItems, action) {\r\n                // Use partial rendering only for change or delete operations with 1 element\r\n                if (items.length == 0)\r\n                    this.lastActionMethod = \"DELETE\";\r\n                else if (index == null)\r\n                    this.lastActionMethod = \"ADD\";\r\n                else if (items.length == 1)\r\n                    this.lastActionMethod = \"EDIT\";\r\n                this.lastActionIndex = index !== null && index !== void 0 ? index : this.length;\r\n                const newValue = items[items.length - 1];\r\n                const oldValue = deletedItems[deletedItems.length - 1];\r\n                ;\r\n                // Return last added, updated or deleted element\r\n                this.lastActionObject = newValue !== null && newValue !== void 0 ? newValue : oldValue;\r\n                self._applyValueAndNotifyObservers(this, observerProperty, componentProperty, newValue, oldValue, true, action);\r\n                // Reset action\r\n                this.lastActionMethod = null;\r\n                this.lastActionIndex = null;\r\n                this.lastActionObject = null;\r\n                this.lastActionPropertyPath = null;\r\n                return this;\r\n            };\r\n            arr.push = function (...items) {\r\n                arr._emit(null, items, [], () => Array.prototype.push.call(this, ...items));\r\n                return arr.length;\r\n            };\r\n            arr.splice = function (index, deleteCount, ...items) {\r\n                const deletedItems = this.slice(index, index + deleteCount);\r\n                if (deleteCount <= 1)\r\n                    arr._emit(index, items, deletedItems, () => Array.prototype.splice.call(this, index, deleteCount, ...items));\r\n                return deletedItems;\r\n            };\r\n            arr.edit = function (index, el) { return this.splice(index, 1, el); };\r\n            arr.delete = function (index) { return this.splice(index, 1); };\r\n        }\r\n    }\r\n    _applyValueAndNotifyObservers(obj, observerProperty, componentProperty, newValue, oldValue, arrayNotification, action) {\r\n        const self = this;\r\n        if (!self._callBindVariableBeforeChangedHook(self, componentProperty, self[componentProperty], self[componentProperty])\r\n            || !self._callBindVariableBeforePropertyChangedHook(self, componentProperty, observerProperty, newValue, oldValue))\r\n            return;\r\n        action();\r\n        obj._observers.get(observerProperty).forEach((componentDetails, component) => {\r\n            componentDetails.forEach((componentPropertyPaths, componentProperty) => {\r\n                componentPropertyPaths.forEach(componentPropertyPath => {\r\n                    // On arrays if length property is changed, array ist changed, so adapt\r\n                    // property path to match expressions depending on array instead of array.length property\r\n                    if (arrayNotification)\r\n                        componentPropertyPath = componentPropertyPath.replace(\".length\", \"\");\r\n                    let bindVariableValue = component.getProperty(componentProperty, undefined);\r\n                    if (bindVariableValue) {\r\n                        if (!arrayNotification)\r\n                            bindVariableValue.lastActionMethod = \"SET\";\r\n                        if (!component._callBindVariableBeforeChangedHook(component, componentProperty, component[componentProperty], component[componentProperty])\r\n                            || !component._callBindVariableBeforePropertyChangedHook(component, componentProperty, componentPropertyPath, newValue, oldValue)) {\r\n                            return;\r\n                        }\r\n                        bindVariableValue.lastActionPropertyPath = componentPropertyPath;\r\n                        component.setProperty(componentProperty, bindVariableValue);\r\n                        component._callBindVariableAfterPropertyChangedHook(self, componentProperty, componentPropertyPath, newValue, oldValue);\r\n                        bindVariableValue.lastActionMethod = null;\r\n                        bindVariableValue.lastActionPropertyPath = null;\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        self._callBindVariableAfterChangedHook(self, componentProperty, self[componentProperty], self[componentProperty]);\r\n    }\r\n    _registerNewObserver(obj, observerProperty, component, componentProperty, componentPropertyPath) {\r\n        let propertyAlreadyObserved = true;\r\n        if (!obj._observers)\r\n            obj._observers = new Map();\r\n        if (!obj._observers.has(observerProperty)) {\r\n            obj._observers.set(observerProperty, new Map());\r\n            propertyAlreadyObserved = false;\r\n        }\r\n        if (!obj._observers.get(observerProperty).has(component))\r\n            obj._observers.get(observerProperty).set(component, new Map());\r\n        if (!obj._observers.get(observerProperty).get(component).has(componentProperty))\r\n            obj._observers.get(observerProperty).get(component).set(componentProperty, []);\r\n        const objObserverList = obj._observers.get(observerProperty).get(component).get(componentProperty);\r\n        if (!objObserverList.includes(componentPropertyPath))\r\n            objObserverList.push(componentPropertyPath);\r\n        return propertyAlreadyObserved;\r\n    }\r\n    _calculateBindings(htmlFunction, bindVariableNames) {\r\n        for (let bindVariableName of bindVariableNames) {\r\n            const regexp = new RegExp(`(${bindVariableName})((\\\\.[\\\\w]+)+)`, 'g');\r\n            this._allBindExpressions[bindVariableName] = [];\r\n            for (const [, , expression] of htmlFunction.matchAll(regexp)) {\r\n                const expr = expression.substring(1);\r\n                if (!this._allBindExpressions[bindVariableName].includes(expr))\r\n                    this._allBindExpressions[bindVariableName].push(expr);\r\n            }\r\n            this._makeBindVariableObservable(bindVariableName);\r\n        }\r\n    }\r\n    _renderFull(htmlFunction, locals) {\r\n        this._locals = locals;\r\n        const [elements, bindVariables, bindVariableNames] = this._parseHTML(htmlFunction, locals);\r\n        const lastExistingElement = this._root.childNodes.length;\r\n        while (elements.length > 0) // Elements are extracted from source at appendChild, therefore always first element\r\n            this._root.appendChild(elements[0]);\r\n        // Incrementally process only those elements recursively that have not been processed via\r\n        // previous renderList or renderContent method within the same render method, so that the\r\n        // same elements are not processed multiple times and added to the observables data structure.\r\n        for (let index = lastExistingElement; index < this._root.childNodes.length; index++)\r\n            this._processElementBinding(this._root.childNodes[index], bindVariables, bindVariableNames);\r\n    }\r\n    _removeObserversForBindVariable(bindVariableToDelete) {\r\n        // Remove observer expressions\r\n        if (this._observersForBindVariable.has(bindVariableToDelete))\r\n            for (const [comp] of this._observersForBindVariable.get(bindVariableToDelete)) {\r\n                for (const [attr, expr] of this._observerExpressions.get(comp)) {\r\n                    if (expr.bindVariableNames.includes(bindVariableToDelete))\r\n                        this._observerExpressions.get(comp).delete(attr);\r\n                }\r\n                if (this._observerExpressions.get(comp).size == 0)\r\n                    this._observerExpressions.delete(comp);\r\n            }\r\n        // Remove observers for bind variable\r\n        this._observersForBindVariable.delete(bindVariableToDelete);\r\n        // Remove bind variable\r\n        delete this._allBindVariables[bindVariableToDelete];\r\n        // Remove all bind expressions for bind variable\r\n        delete this._allBindExpressions[bindVariableToDelete];\r\n    }\r\n    _renderUpdate(value) {\r\n        // Only partially update components that render list, since for other components\r\n        // other element would be added/deleted\r\n        if (this._listTemplate != null) {\r\n            this._locals[this._listIt] = this._listData[value.lastActionIndex];\r\n            // Remove node\r\n            if (value.lastActionMethod == \"DELETE\") {\r\n                this._removeObserversForBindVariable(value.lastActionObject._observableUniqueName);\r\n                this._root.childNodes[this._listStart + value.lastActionIndex].remove();\r\n            }\r\n            else {\r\n                this._locals[this._listIt]._observableUniqueName = this._listIt + (this._renderIteration + 1);\r\n                // Parse new html for added or updated content\r\n                const [elements, bindVariables, bindVariableNames] = this._parseHTML(this._listTemplate, { [this._listIt]: this._listData[value.lastActionIndex] });\r\n                // Add or replace html\r\n                if (value.lastActionMethod == \"ADD\") {\r\n                    if (this._root.childNodes[value.lastActionIndex])\r\n                        this._root.insertBefore(elements[0], this._root.childNodes[this._listStart + value.lastActionIndex - 1].nextSibling);\r\n                    else\r\n                        this._root.appendChild(elements[0]);\r\n                    this._processElementBinding(this._root.childNodes[this._listStart + value.lastActionIndex], bindVariables, bindVariableNames);\r\n                }\r\n                else if (value.lastActionMethod == \"EDIT\") {\r\n                    this._root.replaceChild(elements[0], this._root.childNodes[this._listStart + value.lastActionIndex]);\r\n                    this._processElementBinding(this._root.childNodes[this._listStart + value.lastActionIndex], bindVariables, bindVariableNames);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    _logUpdate(element, name, value) {\r\n        var _a, _b, _c;\r\n        // Filter out function references on first rendering because they are not observed\r\n        if (value[\"bind\"])\r\n            return;\r\n        // If property path is specified, component is not updated, but child component that references property path\r\n        if (value.lastActionPropertyPath)\r\n            return;\r\n        console.log(`[${(_a = element.nodeName) !== null && _a !== void 0 ? _a : \"TEXT\"}]: Update of ${name}: ${(_b = value.lastActionMethod) !== null && _b !== void 0 ? _b : \"SET\"} ${JSON.stringify((_c = value.lastActionObject) !== null && _c !== void 0 ? _c : value)}`);\r\n    }\r\n    _makeDerivedVariablesObservable(variableName, variableBody, html) {\r\n        // Nur global in der Form prop: function() bzw. lokal in der Form prop = function()\r\n        // definierte abgeleitete Properties observable machen (keine regul\u00E4ren Methoden / Funktionen\r\n        // in der Form function name() bzw. name())\r\n        if (!this.DERIVED_PROPERTY_SIGNATURE_REGEX.test(variableBody))\r\n            return html;\r\n        // Make derived bind variables observable\r\n        let referencedBindVariableNames = \"||null\";\r\n        for (const [referencedBindVariableName] of variableBody.matchAll(this.REFERENCED_BIND_VARIABLE_NAMES_REGEX))\r\n            referencedBindVariableNames += \"||\" + referencedBindVariableName;\r\n        return html.replaceAll(`${variableName}`, `(${variableName}()${referencedBindVariableNames})`);\r\n    }\r\n    _calculateTemplateAndBindVariableNames(html, props, locals) {\r\n        this._renderIteration++;\r\n        // Determine all binding variables\r\n        const bindVariables = Object.keys(props);\r\n        // Add additional local variables to binding\r\n        if (locals) {\r\n            for (let [n, v] of Object.entries(locals)) {\r\n                const uniqueBindVariableName = n + this._renderIteration;\r\n                props[uniqueBindVariableName] = v;\r\n                bindVariables.push(uniqueBindVariableName);\r\n                const regexp = new RegExp(`(${n.replaceAll(\"$\", \"\\\\$\")})([^=-])`, 'g');\r\n                for (const [expr, , token] of html.matchAll(regexp))\r\n                    html = html.replace(expr, `${uniqueBindVariableName}${token}`);\r\n                html = this._makeDerivedVariablesObservable(uniqueBindVariableName, v.toString(), html);\r\n            }\r\n        }\r\n        // Make derived global bind variables observable\r\n        const regexp = new RegExp('(this[\\\\w$.]*\\\\.[\\\\w$]+)([(]?)', 'g');\r\n        for (const [, expr, token] of html.matchAll(regexp)) {\r\n            if (token == '(')\r\n                continue;\r\n            // Resolve property variable (defined in componented or referenced from store)\r\n            const index = expr.indexOf(\".\") + 1;\r\n            const functionBody = new Function(\"return \" + expr).call(props).toString().replaceAll(\"this.\", expr.substring(index, expr.indexOf(\".\", index) + 1));\r\n            html = this._makeDerivedVariablesObservable(expr, functionBody, html);\r\n        }\r\n        return [html, bindVariables];\r\n    }\r\n    _processElementBinding(element, bindVariables, bindVariableNames) {\r\n        // Support databinding expressions in attributes (regular DOM elements)\r\n        if (\"attributes\" in element)\r\n            Array.from(element.attributes).forEach((attr) => {\r\n                if (attr.nodeValue.includes(\"${\"))\r\n                    this._processBindingExpression(element, bindVariables, bindVariableNames, attr.nodeName, attr.nodeValue);\r\n            });\r\n        // Support databinding expressions within tags (TextNodes)\r\n        if (\"data\" in element) {\r\n            if (element.data.includes(\"${\"))\r\n                this._processBindingExpression(element, bindVariables, bindVariableNames, \"data\", element.data);\r\n        }\r\n        // Edit child elements recursively\r\n        if (\"childNodes\" in element)\r\n            for (const childElement of Array.from(element.childNodes)) {\r\n                this._processElementBinding(childElement, bindVariables, bindVariableNames);\r\n            }\r\n        // Render elements with render support      \r\n        if (\"_hasAlreadyRendered\" in element && !element._hasAlreadyRendered())\r\n            element.render();\r\n    }\r\n    _processBindingExpression(element, bindVariables, bindVariableNames, attr, expr) {\r\n        // Build callable expression to (re)calculate value of attribute based on depending binding variables  \r\n        const attributeExpression = this._buildCallableExpression(attr, expr, bindVariableNames);\r\n        // Save attribute expression for later execution on bind variable changes\r\n        if (!this._observerExpressions.has(element))\r\n            this._observerExpressions.set(element, new Map());\r\n        this._observerExpressions.get(element).set(attr, attributeExpression);\r\n        // Rebind this of subproperties to parent property\r\n        for (let bindVariableName of attributeExpression.bindVariableNames) {\r\n            if (bindVariables[bindVariableName].bind)\r\n                bindVariables[bindVariableName] = bindVariables[bindVariableName].bind(this); // pass this from parent to child on callbacks that are passed down\r\n        }\r\n        // Determine current values\r\n        const bindVariableValues = this._getBindVariableValues(attributeExpression.bindVariableNames);\r\n        // Get current value of element attribute by evaluating expression\r\n        const value = attributeExpression.execute(...bindVariableValues);\r\n        element[attr] = value;\r\n        // Register combination of element and attribute as observer for each bind variable name\r\n        if (!value[\"bind\"]) // Do not observe functions\r\n            this._registerElementAttributeAsObserverForBindVariables(element, attr, bindVariables, attributeExpression.bindVariableNames);\r\n    }\r\n    _buildCallableExpression(attr, expr, bindVariableNames) {\r\n        // If expression is the only expression, do not interpret it as string,\r\n        // but evaluate directly so that references to functions can be assigned to properties\r\n        if (attr == \"data\" || expr.lastIndexOf(\"${\") > 0 || expr.lastIndexOf(\"}\") < expr.length - 1)\r\n            expr = \"`\" + expr + \"`\";\r\n        else\r\n            expr = expr.replaceAll(\"${\", \"\").replaceAll(\"}\", \"\");\r\n        let referencedBindVariables = [];\r\n        for (const bindVariableName of bindVariableNames) {\r\n            if (expr.includes(bindVariableName))\r\n                referencedBindVariables.push(bindVariableName);\r\n        }\r\n        // Currently, in addition to the local variables (additional variables passed to renderContent/renderList),\r\n        // the WebComponent's properties are also passed as local variables to the WebComponent's attribute function,\r\n        // which is not really necessary, but facilitates the generic handling\r\n        return new AttributeExpression(new Function(...referencedBindVariables, \"return \" + expr).bind(this), referencedBindVariables, expr);\r\n    }\r\n    _registerElementAttributeAsObserverForBindVariables(element, attr, bindVariables, referencedBindVariableNames) {\r\n        // Add combination of element and attribute to observer structure\r\n        for (let bindVariableName of referencedBindVariableNames) {\r\n            if (!this._observersForBindVariable.has(bindVariableName))\r\n                this._observersForBindVariable.set(bindVariableName, new Map());\r\n            const variableObservable = this._observersForBindVariable.get(bindVariableName);\r\n            if (!variableObservable.has(element))\r\n                variableObservable.set(element, []);\r\n            if (bindVariables[bindVariableName].bind)\r\n                bindVariables[bindVariableName] = bindVariables[bindVariableName].bind(this); // pass this from parent to child on callbacks that are passed down\r\n            variableObservable.get(element).push(attr);\r\n        }\r\n    }\r\n    _getBindVariableValues(bindVariableNames) {\r\n        let result = [];\r\n        for (const b of bindVariableNames)\r\n            result.push(this._allBindVariables[b]);\r\n        return result;\r\n    }\r\n    _updatePropertyObservers(bindVariable) {\r\n        const [bindVariableName, bindVariableValue] = bindVariable;\r\n        // Render partially only if element has already been created.\r\n        // (Setters should also be able to be called before component\r\n        // has been created for the first time, which is why state setters\r\n        // only change state here, but have no effect on UI yet).\r\n        if (this._observersForBindVariable.has(bindVariableName)) {\r\n            for (const [element, attrs] of this._observersForBindVariable.get(bindVariableName).entries()) {\r\n                for (const attrName of attrs) {\r\n                    const attrExpr = this._observerExpressions.get(element).get(attrName);\r\n                    if (!bindVariableValue.lastActionPropertyPath || attrExpr.template.includes(bindVariableValue.lastActionPropertyPath)) {\r\n                        // Reevaluate binding expression\r\n                        const bindVariableValues = this._getBindVariableValues(attrExpr.bindVariableNames);\r\n                        const newValue = attrExpr.execute(...bindVariableValues);\r\n                        // Always propagate changes in properties to all observer elements and\r\n                        // propagate changes in subproperties only if subproperty is included in binding expression / template\r\n                        // (e.g. if data.selectedPerson.name is changed, only attributes with bindings to data, data.selectedPerson\r\n                        // and data.selectedPerson.name, but e.g. not on data.selectedPerson.age).\r\n                        if (typeof newValue.lastActionIndex != \"undefined\" || !bindVariableValue.lastActionPropertyPath || attrExpr.template && attrExpr.template.includes(bindVariableValue.lastActionPropertyPath)) {\r\n                            // Always update HofHTMLElement to pass down subproperty changes to sub components,\r\n                            // but update simple html elements only if value changed\r\n                            if (element instanceof HofHtmlElement || element[attrName] != newValue) {\r\n                                // this._logUpdate(element, attrName, newValue);\r\n                                element[attrName] = newValue;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n// Helper function to support functional component definition as alternative to class based web component implementation\r\nexport function component(name, obj, tag = \"div\") {\r\n    let componentConstructor = class extends HofHtmlElement {\r\n        constructor() { super(tag); super.useAutoProps(); }\r\n        render() { }\r\n    };\r\n    componentConstructor[\"componentName\"] = name;\r\n    for (const prop of Object.keys(obj))\r\n        if (prop == \"render\") {\r\n            const func = obj[prop]();\r\n            const variables = _calculateLocalVariables(prop);\r\n            delete componentConstructor[\"render\"];\r\n            if (Array.isArray(func)) {\r\n                const renderFuncs = [];\r\n                if (func.length > 0 && Array.isArray(func[0])) // Array with render function\r\n                    for (const renderExpr of func)\r\n                        renderFuncs.push(_calculateRenderFunc(renderExpr));\r\n                else\r\n                    renderFuncs.push(_calculateRenderFunc(func));\r\n                componentConstructor.prototype[\"render\"] = function () { renderFuncs.forEach((renderFunc => renderFunc(this, variables))); };\r\n            }\r\n            else // Call function\r\n                componentConstructor.prototype[\"render\"] = function () { this.renderContent(func, variables); };\r\n        }\r\n        else {\r\n            // Due to a bug in current JS implementations, DOM events are also executed when the getter is\r\n            // accessed, which leads to errors if DOM element / web component is not yet inserted in the\r\n            // real DOM, so that the onXY events are stored here under a different name and later\r\n            // registered within the class under the correct name (this works because the custom element\r\n            // has already been registered than)\r\n            componentConstructor.prototype[\"event-\" + prop] = obj[prop];\r\n        }\r\n    function _calculateRenderFunc(func) {\r\n        if (func.length == 1) // Call [function]\r\n            return function (obj, variables) { obj.renderContent(func[0], variables); };\r\n        else if (func.length == 2 && typeof (func[0]) == \"function\") // Call [function, variables]\r\n            return function (obj) { obj.renderContent(func[0], func[1]); };\r\n        else if (func.length >= 2 && typeof (func[1]) == \"function\") // Call [listVariable, function, variables]\r\n            return function (obj, variables) { var _a, _b; obj.renderList((_a = obj[func[0]]) !== null && _a !== void 0 ? _a : func[0], func[1], (_b = func[2]) !== null && _b !== void 0 ? _b : variables); };\r\n        else\r\n            throw new Error(\"Invalid render function argument!\");\r\n    }\r\n    function _calculateLocalVariables(prop) {\r\n        let functionDefinition = obj[prop].toString();\r\n        let begin = functionDefinition.indexOf(\"{\") + 1;\r\n        let end = functionDefinition.lastIndexOf(\"return\");\r\n        let functionBody = functionDefinition.substring(begin, end);\r\n        // Filter out comments\r\n        functionBody = functionBody.replace(/\\/\\*[\\s\\S]*?\\*\\/|([^:]|^)\\/\\/.*$/gm, ' ');\r\n        // Calculate variable names\r\n        const regexps = [\r\n            new RegExp(`let[^\\\\w$]+([\\\\w$]+)[\\\\W]*=`, 'g'),\r\n            new RegExp(`const[^\\\\w$]+([\\\\w$]+)[\\\\W]*=`, 'g'),\r\n            new RegExp(`function[^\\\\w$]+([\\\\w$]+)\\\\(`, 'g')\r\n        ];\r\n        const variables = [];\r\n        for (const regexp of regexps)\r\n            for (const [, variable] of functionBody.matchAll(regexp))\r\n                variables.push(variable);\r\n        // Calculate variable values\r\n        if (variables.length > 0)\r\n            return new Function(functionBody + \"return {\" + variables.join(\",\") + \"}\").call(obj);\r\n        else\r\n            return [];\r\n    }\r\n    customElements.define(name, componentConstructor);\r\n    return componentConstructor;\r\n}\r\n", "import { HofHtmlElement } from \"@hofjs/hofjs/lib/esm/hof\";\r\n\r\ninterface RoutesConfig {\r\n    [routeName: string]: RouteConfig\r\n}\r\n\r\ninterface RouteConfig {\r\n    url: string;\r\n    component: new() => HofHtmlElement;\r\n    params: Object;\r\n    redirect: string;\r\n    aliases: string[];\r\n}\r\n\r\ninterface Routes {\r\n    [routeName: string]: Route\r\n}\r\n\r\ninterface Route extends RouteConfig {\r\n    urlRegex: RegExp,\r\n    aliasesRegexes: RegExp[];\r\n    renderElementParent: ShadowRoot;\r\n    renderElementId: string;\r\n}\r\n\r\ninterface RouteInfo {\r\n    url: string;\r\n    query: string;\r\n    params: Object;\r\n}\r\n\r\ninterface UrlParams {\r\n    [routeName: string]: string\r\n}\r\n\r\nexport class HofRouter {\r\n    static initialized: boolean = false;\r\n    static routes: Routes = {};\r\n    static defaultRoute: Route = null;\r\n    static current: RouteInfo = null;\r\n\r\n    static _setup() {\r\n        HofRouter.initialized = true;\r\n        window.onload = () => {                 \r\n            HofRouter.processRoute(document.location.href, true, false);\r\n\r\n            document.body.addEventListener('click', function(e: MouseEvent) {\r\n                const el = e[\"path\"][0];\r\n                if (el.nodeName == 'A') {\r\n                    e.preventDefault();\r\n                    HofRouter.processRoute(el.attributes[0].nodeValue);\r\n                }\r\n            });\r\n        }\r\n        window.onpopstate = (event: PopStateEvent) => { HofRouter.processRoute(event.state.url, false, false);}\r\n    }\r\n\r\n    static _buildRoute(renderElementParent: ShadowRoot, renderElementId: string, config: RouteConfig): Route {\r\n        return {\r\n            url: config.url,\r\n            urlRegex: calculatePathExpression(config.url), // Support shortcut parameter syntax :param\r\n            component: config.component,\r\n            params: config.params,\r\n            redirect: config.redirect,\r\n            aliases: config.aliases,\r\n            aliasesRegexes: config.aliases?.map(alias => calculatePathExpression(alias)),\r\n            renderElementParent, renderElementId\r\n        };\r\n\r\n        function calculatePathExpression(path: string): RegExp {\r\n            if (path == \"*\")\r\n                return new RegExp(\"^.*$\");\r\n\r\n            return new RegExp(\"^\" + path.replace(/:([a-zA-Z0-9]+)/, \"(?<$1>[\\\\w-]+)\") + \"(\\\\?(?<$routeQuery>.*))?$\");\r\n        }\r\n    }\r\n\r\n    static configRoutes(renderElementParent: ShadowRoot, renderElementId: string, routeEntries: RoutesConfig) {\r\n        if (!HofRouter.initialized) HofRouter._setup();\r\n\r\n        for (const [name, config] of Object.entries(routeEntries)) {\r\n            const route = HofRouter._buildRoute(renderElementParent, renderElementId, config);\r\n\r\n            if (config.url == \"*\") HofRouter.defaultRoute = route;\r\n            else HofRouter.routes[name] = route;\r\n        }\r\n    }\r\n\r\n    static _findCurrentView(mountElement: HTMLElement): HofHtmlElement {\r\n        for (const child of Array.from(mountElement.children))\r\n            if (child[\"style\"] && child[\"style\"].display != 'none')\r\n                return child as HofHtmlElement;\r\n\r\n        return null;\r\n    }\r\n\r\n    static _findNextView(mountElement: HTMLElement, route: Route): HofHtmlElement {\r\n        for (const child of Array.from(mountElement.children))\r\n            if (child instanceof HofHtmlElement && child.getAttribute(\"router-url\") == route.url)\r\n                return child;\r\n\r\n        return null;\r\n    }\r\n\r\n    static _updateView(view: HofHtmlElement, route: Route, urlParams: UrlParams) {\r\n        // Initialize component with configured parameters\r\n        for (const param in route.params)\r\n            view[param] = route.params[param];\r\n\r\n        // Build injectable route object\r\n        const routeInfo = { url: route.url, params: {}, query: \"\" };\r\n        for (const param in urlParams) {                             \r\n            if (param == \"$routeQuery\") {\r\n                if (typeof urlParams[param] != 'undefined') {\r\n                    for (const paramExpr of urlParams[param].split(\"&\")) {\r\n                        const paramNameAndValue = paramExpr.split(\"=\");\r\n                        if (paramNameAndValue.length == 2)\r\n                        routeInfo.params[paramNameAndValue[0]] = paramNameAndValue[1];\r\n                    }\r\n\r\n                    routeInfo.query = urlParams[param];\r\n                }\r\n            }\r\n            else\r\n                view[param] = urlParams[param];\r\n        }\r\n\r\n        HofRouter.current = routeInfo;\r\n         \r\n        view.setAttribute(\"router-url\", route.url);\r\n    }\r\n\r\n    static _loadView(mountElement: HTMLElement, route: Route, urlParams: UrlParams) {\r\n        const view = new route.component();\r\n        \r\n        // View should be initially hidden\r\n        view.style.display = 'none';\r\n\r\n        HofRouter._updateView(view as HofHtmlElement, route, urlParams);\r\n\r\n        mountElement.appendChild(view);\r\n        \r\n        view.render();\r\n\r\n        return view;\r\n    }\r\n\r\n    static _callBeforeRoutingHook(view: HofHtmlElement, nextUrl: string, currentUrl: string) {\r\n        if (view != null && view[\"beforeRouting\"]) {\r\n            const ret = view[\"beforeRouting\"](nextUrl, currentUrl);\r\n            if (typeof ret != \"undefined\" && ret == false)\r\n                return false; \r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    static _callAfterRoutingHook(view: HofHtmlElement, nextUrl: string, currentUrl: string) {\r\n        if (view != null && view[\"afterRouting\"])\r\n            view[\"afterRouting\"](nextUrl, currentUrl);\r\n    }\r\n\r\n    static _resolveRouterUrl(url: string) {\r\n        // Sample: <a href=\"router:pageDetails(id=1, param1=Hello, param2=World)\">Details 3</a>\r\n\r\n        const paramsStartIndex = url.indexOf(\"(\");\r\n        const paramsEndIndex = url.indexOf(\")\");\r\n        const routeName = paramsStartIndex == -1 ? url.substring(7) : url.substring(7, paramsStartIndex);\r\n        const parametersExpr = paramsStartIndex == -1 ? \"\" : url.substring(paramsStartIndex+1, paramsEndIndex);\r\n\r\n        // Resolve integrated router functions\r\n        if (routeName == \"back\") { HofRouter.back(); return null; }\r\n        else if (routeName == \"forward\") { HofRouter.forward(); return null; }\r\n        else if (routeName == \"go\") { HofRouter.go(parseInt(parametersExpr)); return null; }\r\n        else if (routeName == \"push\") { HofRouter.push(parametersExpr); return null; }\r\n        else if (routeName == \"replace\") { HofRouter.replace(parametersExpr); return null; }\r\n\r\n        let resolvedUrl = HofRouter.routes[routeName].url;\r\n        let resolvedUrlQuery = \"?\";\r\n\r\n        if (parametersExpr)\r\n            for (const param of parametersExpr.split(\",\")) {\r\n                let [name, value] = param.trim().split(\"=\");\r\n                \r\n                if (resolvedUrl.includes(`:${name}`))\r\n                    resolvedUrl = resolvedUrl.replace(`:${name}`, value);\r\n                else\r\n                    resolvedUrlQuery += `${name}=${value}&`;\r\n            }\r\n        resolvedUrlQuery = resolvedUrlQuery.substring(0, resolvedUrlQuery.length-1);\r\n        resolvedUrl += resolvedUrlQuery;\r\n\r\n        return resolvedUrl;\r\n    }\r\n\r\n    static _matchRoute(nextUrl: string, route: Route, updateHistory: boolean, addMode: boolean) {\r\n        if (nextUrl.startsWith(\"router:\")) {\r\n            nextUrl = HofRouter._resolveRouterUrl(nextUrl);\r\n            \r\n            // Router action already processed, i.e. no nextUrl\r\n            if (nextUrl == null) return true;\r\n        }\r\n\r\n        const match = route.urlRegex.exec(nextUrl)\r\n            ?? route.aliasesRegexes?.map(alias => alias.exec(nextUrl)).find(alias => alias != null);\r\n\r\n        if (match != null) {\r\n            if (route.redirect) return true;\r\n\r\n            const mountElement = route.renderElementParent.getElementById(route.renderElementId);\r\n            const currentViewComponent = HofRouter._findCurrentView(mountElement);\r\n            const currentUrl = currentViewComponent?.getAttribute(\"router-url\");\r\n            const urlParams = match.groups;\r\n            const nextViewComponent = HofRouter._findNextView(mountElement, route)\r\n                ?? HofRouter._loadView(mountElement, route, urlParams);\r\n\r\n            HofRouter._callBeforeRoutingHook(currentViewComponent, nextUrl, currentUrl);\r\n            HofRouter._callBeforeRoutingHook(nextViewComponent, nextUrl, currentUrl);\r\n\r\n            if (currentViewComponent)\r\n                currentViewComponent.style.display = 'none';\r\n            nextViewComponent.style.display = '';\r\n\r\n            HofRouter._updateView(nextViewComponent, route, urlParams);\r\n\r\n            if (updateHistory) {\r\n                if (addMode) history.pushState({ url: nextUrl }, \"\", nextUrl);                       \r\n                else history.replaceState({ url: nextUrl }, \"\", nextUrl);                            \r\n            }\r\n\r\n            HofRouter._callAfterRoutingHook(currentViewComponent, nextUrl, currentUrl);\r\n            HofRouter._callAfterRoutingHook(nextViewComponent, nextUrl, currentUrl);\r\n            \r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    static processRoute(nextUrl: string, updateHistory: boolean = true, addMode: boolean = true) {\r\n        // Try to match against regular routes\r\n        for (const route of Object.values(HofRouter.routes)) {\r\n            if (HofRouter._matchRoute(nextUrl, route, updateHistory, addMode)) {\r\n                if (route.redirect)\r\n                    HofRouter.processRoute(route.redirect, updateHistory, addMode);\r\n\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Try to match against default route\r\n        if (HofRouter.defaultRoute && HofRouter._matchRoute(nextUrl, HofRouter.defaultRoute, updateHistory, addMode)) {\r\n            if (HofRouter.defaultRoute.redirect)\r\n                HofRouter.processRoute(HofRouter.defaultRoute.redirect, updateHistory, addMode);\r\n\r\n            return;\r\n        }\r\n\r\n        // No matching route found\r\n        throw Error(`No matching route definition to resolve url ${nextUrl}!`);\r\n    }\r\n\r\n    static back() { history.back(); }\r\n    static forward() { history.forward(); }\r\n    static go(delta: number) { history.go(delta); }\r\n    static push(url: string) { HofRouter.processRoute(url, true, true); }\r\n    static replace(url: string) { HofRouter.processRoute(url, true, false); }\r\n}", "// File, which is used to import library via regular import mechanism\r\n// but then adding imported entities to the window object\r\n// so that even without modules the JavaScript code will be executed\r\n// and can be used directly in a web application (this file is used\r\n// by esbuild to create nomodule version of this library)\r\n\r\n// Import elements of library\r\nimport { HofRouter } from '../hofrouter'\r\n\r\n// Make elements of library accessible on the window object\r\n(window as any).HofRouter = HofRouter;"],
  "mappings": "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",
  "names": []
}
